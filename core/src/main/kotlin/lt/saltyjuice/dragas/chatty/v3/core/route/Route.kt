package lt.saltyjuice.dragas.chatty.v3.core.route

import lt.saltyjuice.dragas.chatty.v3.core.exception.RouteBuilderException
import lt.saltyjuice.dragas.chatty.v3.core.main.Utility
import lt.saltyjuice.dragas.chatty.v3.core.middleware.AfterMiddleware
import lt.saltyjuice.dragas.chatty.v3.core.middleware.BeforeMiddleware
import lt.saltyjuice.dragas.chatty.v3.core.middleware.MiddlewareUtility
import java.lang.reflect.Method
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.streams.toList

/**
 * A simple route class that holds all abstraction related to Routing in general.
 *
 * Key idea here is that [Request] objects are matched by [testCallback] callback and then a
 * [callback] is triggered, which is supposed to generate a non-nullable [Response] object. Since [callback]
 * is a lambda reference, you can implement MVC pattern (or model-response-controller) around
 * route objects.
 */
open class Route<Request, Response>
{
    /**
     * Holds reference to all before middlewares used by this route.
     */
    protected open val beforeMiddlewares: MutableList<BeforeMiddleware<Request>> = mutableListOf()
    /**
     * Holds reference to all aftermiddlewares used by this route.
     */
    protected open val afterMiddlewares: MutableList<AfterMiddleware<Response>> = mutableListOf()
    /**
     * Invoked, when this route is being tested.
     */
    protected open var testCallback: (Route<Request, Response>, Request) -> Boolean = { route, request -> true }
    /**
     * Invoked when this route passes all tests.
     */
    protected open var callback: (Route<Request, Response>, Request) -> Unit = { route, request -> }
    /**
     * Holds reference to controller class, which is later used to create new controller instances.
     */
    protected lateinit open var controllerClazz: Class<*>
    /**
     * Provides description for this route.
     */
    protected open var description: String = ""
    /**
     * Notes if this route's controller is a singleton - if it shouldn't be remade every time a request can use it.
     */
    protected open var singleton = false
    /**
     * Holds current controller instance
     */
    protected open var controllerInstanceHolder: Controller<Response>? = null
    /**
     * Internal response holder.
     */
    @JvmField
    protected val responsesInternal: MutableList<Response> = mutableListOf()

    /**
     * Thread safe field which denotes, if controller can be reused.
     */
    private val canBeReused: AtomicBoolean = AtomicBoolean(false)

    /**
     * Returns new or current controller instance, if controller is a singleton.
     */
    open fun getControllerInstance(): Controller<Response>
    {
        if (controllerInstanceHolder == null || !(singleton || canBeReused.get()))
            controllerInstanceHolder = controllerClazz.newInstance() as Controller<Response>
        return getCurrentControllerInstance()
    }

    /**
     * Returns currently used controller instance.
     */
    open fun getCurrentControllerInstance(): Controller<Response>
    {
        return controllerInstanceHolder!!
    }

    /*open fun getChannel(): SendChannel<Response>
    {
        return responseChannel!!
    }*/

    /**
     * Tests the request by first checking whether or not it passes the middleware test,
     * only after it does it test for actual patterns.
     */
    open fun canTrigger(request: Request): Boolean
    {
        return (beforeMiddlewares.firstOrNull { it -> !it.before(request) } == null && testCallback(this, request)).also { canBeReused.set(!it) }
    }

    /**
     * Tests whether or not particular response can be sent back to the server.
     */
    open fun canRespond(response: Response): Boolean
    {
        return afterMiddlewares.firstOrNull { it -> !it.after(response) } == null
    }

    /**
     * Tries pushing response to response list generated by this route
     */
    open fun attemptRespond(response: Response)
    {
        if (canRespond(response))
        {
            responsesInternal.add(response)
        }
    }

    open fun getResponses(): List<Response>
    {
        return Utility.copyAndClean(responsesInternal)
    }

    /**
     * Attempts consuming the provided request. On failure, [getResponses] returns an empty list. if a controller fails
     * to consume a request, it stays the way it is.
     */
    open fun attemptTrigger(request: Request)
    {
        if (canTrigger(request))
        {
            callback(this, request)
            val responses = getCurrentControllerInstance().getResponses()
            responses.forEach(this::attemptRespond)
        }
        getCurrentControllerInstance().getResponses() // cleans the generated responses, if there were any.
    }

    /**
     * The base route builder for all Chatty implementations.
     *
     * Contains several very basic methods that help you build routes for [Router]
     */
    abstract class Builder<Request, Response>
    {
        protected open val mBeforeMiddlewares: MutableList<BeforeMiddleware<Request>> = mutableListOf()
        protected open val mAfterMiddlewares: MutableList<AfterMiddleware<Response>> = mutableListOf()
        protected open var mCallback: ((Route<Request, Response>, Request) -> Unit) = { route, it -> }
        protected open var mTestCallback: ((Route<Request, Response>, Request) -> Boolean) = { route, it -> false }
        protected open var mDescription: String = ""
        protected open var mSingleton: Boolean = false
        protected open lateinit var mControllerClazz: Class<*>
        private var superConsumeMethodCalledWhenBuilding = false
        private var superAdaptCalled = false

        @Throws(RouteBuilderException::class)
        open fun before(clazz: Class<out BeforeMiddleware<Request>>): Builder<Request, Response>
        {
            val middleware = MiddlewareUtility.getBeforeMiddleware(clazz as Class<BeforeMiddleware<*>>)
            if (mBeforeMiddlewares.contains(middleware))
                throw RouteBuilderException("Particular middleware is already declared for this callback: $clazz")
            mBeforeMiddlewares.add(middleware as BeforeMiddleware<Request>)
            return this
        }

        @Throws(RouteBuilderException::class)
        open fun after(clazz: Class<out AfterMiddleware<Response>>): Builder<Request, Response>
        {
            val middleware = MiddlewareUtility.getAfterMiddleware(clazz as Class<AfterMiddleware<*>>)
            if (mAfterMiddlewares.contains(middleware))
                throw RouteBuilderException("Particular middleware is already declared for this callback: $clazz")
            mAfterMiddlewares.add(middleware as AfterMiddleware<Response>)
            return this
        }

        open fun callback(callback: (Route<Request, Response>, Request) -> Unit): Builder<Request, Response>
        {
            this.mCallback = callback
            return this
        }

        open fun testCallback(callback: (Route<Request, Response>, Request) -> Boolean): Builder<Request, Response>
        {
            this.mTestCallback = callback
            return this
        }

        open fun description(string: String): Builder<Request, Response>
        {
            this.mDescription = string
            return this
        }


        open fun controller(clazz: Class<out Controller<Response>>): Builder<Request, Response>
        {
            this.mControllerClazz = clazz
            return this
        }

        fun singleton(singleton: Boolean): Builder<Request, Response>
        {
            this.mSingleton = singleton
            return this
        }

        fun build(): Route<Request, Response>
        {
            val route = adapt(returnableRoute())
            if (!superAdaptCalled)
                throw RouteBuilderException("super.adapt() was not called!")
            return route
        }

        /**
         * Implementations should return a raw route object which is later used in [adapt] to add all the callbacks, middlewares, etc.
         */
        abstract fun returnableRoute(): Route<Request, Response>

        /**
         * Copies all fields from this [Builder] to provided route. Anyone overriding this method MUST call super.adapt(route)
         */
        open fun adapt(route: Route<Request, Response>): Route<Request, Response>
        {
            route.beforeMiddlewares.addAll(mBeforeMiddlewares)
            route.afterMiddlewares.addAll(mAfterMiddlewares)
            route.callback = mCallback
            route.testCallback = mTestCallback
            route.description = mDescription
            route.controllerClazz = mControllerClazz
            route.singleton = mSingleton
            superAdaptCalled = true
            return route
        }

        /**
         * Consumes controller class with provided global middlewares.
         *
         * @return a list of all route builders that may build a route.
         */
        @Throws(RouteBuilderException::class)
        fun consume(controller: Class<out Controller<Response>>, beforeMiddlewares: List<Class<out BeforeMiddleware<Request>>>, afterMiddlewares: List<Class<out AfterMiddleware<Response>>>): List<Route.Builder<Request, Response>>
        {
            return controller
                    .methods
                    .toList()
                    .parallelStream()
                    .filter { it.getAnnotation(On::class.java) != null }
                    .map()
                    { method ->
                        val builder = this.javaClass.newInstance()
                        afterMiddlewares.forEach { builder.after(it) }
                        beforeMiddlewares.forEach { builder.before(it) }
                        builder.consume(controller, method)
                        if (!builder.superConsumeMethodCalledWhenBuilding)
                            throw RouteBuilderException("super.consumeMethod() was not called.")
                        builder
                    }
                    .toList()
        }

        /**
         * Should any additional annotations be added later in core or protocol implementations, they should be scrapped here.
         * Calling super is mandatory.
         */
        @Throws(RouteBuilderException::class)
        open fun consume(controller: Class<out Controller<Response>>, method: Method): Route.Builder<Request, Response>
        {
            val type = method.getAnnotation(On::class.java).clazz
            description(method.getAnnotation(Description::class.java)?.value ?: "${controller.canonicalName}#${method.name}")
            singleton(controller.getAnnotation(Singleton::class.java) != null)
            controller(controller)
            try
            {
                MiddlewareUtility.getBeforeMiddlewares(method).forEach { before(it as Class<BeforeMiddleware<Request>>) }
                MiddlewareUtility.getAfterMiddlewares(method).forEach { after(it as Class<AfterMiddleware<Response>>) }
                MiddlewareUtility.getBeforeMiddlewares(controller).forEach { before(it as Class<BeforeMiddleware<Request>>) }
                MiddlewareUtility.getAfterMiddlewares(controller).forEach { after(it as Class<AfterMiddleware<Response>>) }
            }
            catch (err: RouteBuilderException)
            {
                throw RouteBuilderException("For ${controller.canonicalName}.${method.name}")
            }
            callback()
            { route, request ->
                val controllerCopy = route.getCurrentControllerInstance()
                method.invoke(controllerCopy, request)
            }
            testCallback()
            { route, it ->
                it as Any
                route.getControllerInstance()
                type.javaObjectType.isAssignableFrom(it.javaClass)
            }

            method.getAnnotation(When::class.java)?.apply()
            {
                val testMethod = controller.methods.find { method -> method.name == value }
                testMethod ?: throw RouteBuilderException("Unable to find method named $value in ${controller.canonicalName}. Note: It's case sensitive.")
                testCallback()
                { route, request ->
                    request as Any
                    val controllerInstance = route.getControllerInstance()
                    type.javaObjectType.isAssignableFrom(request.javaClass) && testMethod.invoke(controllerInstance, request) as Boolean
                }
            }
            superConsumeMethodCalledWhenBuilding = true
            return this
        }
    }
}